Perfeito, Miguel. Para garantir que a IA do Replit **compreenda completamente o fluxo e integre sem erro**, aqui est√° o **bloco completo de instru√ß√£o para a fun√ß√£o `handleSubmitPost()`**, com:

- Vari√°veis auxiliares necess√°rias
- Integra√ß√£o com React Hook Form
- Observa√ß√µes de compatibilidade com o backend (multer + JWT)

---

## üì¶ Instru√ß√µes completas para o Replit ‚Äî Cria√ß√£o de Post com Upload e Rich Text

---

### ‚úÖ 1. **Requisitos de ambiente e depend√™ncias j√° consideradas:**

- `React Hook Form` com `useForm()` ativo
- Token JWT armazenado em `localStorage` com a chave `"token"`
- Backend usando `multer.fields([{ name: 'imagem' }, { name: 'anexo' }])`

---

### ‚úÖ 2. **Configura√ß√£o no topo do componente `PostManager.tsx`**

```tsx
import { useForm } from "react-hook-form";
import { toast } from "@/components/ui/use-toast";
import { useState } from "react";
import { queryClient } from "@/lib/queryClient";

const { register, handleSubmit, reset: resetForm, control } = useForm();

const [submitting, setSubmitting] = useState(false);
const [imagemSelecionada, setImagemSelecionada] = useState<File | null>(null);
const [anexoSelecionado, setAnexoSelecionado] = useState<File | null>(null);
```

> Use `setImagemSelecionada` e `setAnexoSelecionado` nos inputs `<input type="file">` para capturar os arquivos selecionados.

---

### ‚úÖ 3. **Fun√ß√£o `handleSubmitPost()` completa e revisada**

```tsx
const handleSubmitPost = async (values: any) => {
  try {
    setSubmitting(true);

    const formData = new FormData();
    formData.append('titulo', values.titulo);
    formData.append('categoria', values.categoria);
    formData.append('youtubeUrl', values.youtubeUrl || '');
    formData.append('conteudo', values.conteudo || '');

    if (imagemSelecionada instanceof File) {
      formData.append('imagem', imagemSelecionada);
    }

    if (anexoSelecionado instanceof File) {
      formData.append('anexo', anexoSelecionado);
    }

    const token = localStorage.getItem("token");

    const response = await fetch('/api/posts', {
      method: 'POST',
      body: formData,
      headers: {
        Authorization: `Bearer ${token}`
      }
    });

    if (!response.ok) {
      const text = await response.text();
      throw new Error(`Erro ${response.status}: ${text}`);
    }

    toast({
      title: "Postagem criada com sucesso!",
      variant: "success",
    });

    resetForm();
    setImagemSelecionada(null);
    setAnexoSelecionado(null);
    queryClient.invalidateQueries(['posts']);

  } catch (error: any) {
    console.error("Erro ao criar post:", error);
    toast({
      title: "Erro ao criar post",
      description: error.message || "Erro desconhecido.",
      variant: "destructive",
    });
  } finally {
    setSubmitting(false);
  }
};
```

---

### ‚úÖ 4. **Exemplo de inputs de arquivo**

```tsx
<input
  type="file"
  accept="image/*"
  onChange={(e) => {
    if (e.target.files?.[0]) setImagemSelecionada(e.target.files[0]);
  }}
/>

<input
  type="file"
  accept=".pdf,.zip,.rar"
  onChange={(e) => {
    if (e.target.files?.[0]) setAnexoSelecionado(e.target.files[0]);
  }}
/>
```

---

### ‚úÖ 5. **Uso no bot√£o do formul√°rio**

```tsx
<form onSubmit={handleSubmit(handleSubmitPost)}>
  {/* ...inputs do formul√°rio */}
  <button type="submit" disabled={submitting}>
    {submitting ? "Enviando..." : "Criar Postagem"}
  </button>
</form>
```

---

Com essas instru√ß√µes, a IA do Replit ou outro assistente pode reconstruir todo o fluxo corretamente, compat√≠vel com seu backend atual. Se quiser, posso compactar isso em um arquivo `.tsx` de exemplo pronto. Deseja isso?